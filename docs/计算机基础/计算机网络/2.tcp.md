## 数据包
![](2.tcp.assets/12605)

### Source Port（16位）
- 源端口

### Destination Port（16位）
- 目标端口

### Sequence Number（32位）
- 本报文段第一个字节的序列号
- 如果到达最大值了后就循环到0
- ISN（初始序列号）
    - 在三次握手的过程当中，双方会用过SYN报文来交换彼此的 ISN
    - ISN 并不是一个固定的值，而是每 4 ms 加一，溢出则回到 0，这个算法使得猜测 ISN 变得很困难

### Acknowledgment Number（32位）
- 用来告知对方下一个期望接收的序列号，小于ACK的所有字节已经全部收到

### Header Length（4位）
- 首部长度
- 固定部分为20字节
- 若有可选项内容，最长可以为60字节
- 计算方法（转换为十进制值后再乘以4）

### 保留（6位）
- 无用

### TCP Flag（6位）
- ACK 确认
- SYN 同步
- FIN 释放连接
- URG 紧急标志位，表示的是此报文段中有紧急数据，将紧急数据排在普通数据的前面；当接受端收到此报文后后必须先处理紧急数据，而后再处理普通数据
- PSH 催促标志位，当发送端将PSH置为1时，TCP会立即创建一个报文并发送。接受端收到PSH为1的报文后就立即将接受缓冲区内数据向上交付给应用程序，而不是等待缓冲区满后再交付
- RST 用于重置由于主机崩溃或其他原因而出现错误的连接或者用于拒绝非法的报文段和拒绝连接请求

### Window size value（16位）
- 2^16次方，实际上是不够用的
- 因此 TCP 引入了窗口缩放（可选项），作为窗口缩放的比例因子，这个比例因子的范围在 0 ~ 14，比例因子可以将窗口的值扩大为原来的 2 ^ n 次方

### Checksum（16位）
- 防止传输过程中数据包有损坏，如果遇到校验和有差错的报文，TCP 直接丢弃之，等待重传

### Urgent pointer（16位）
- 当标记位URG为1时启用，指向报文中，紧急数据的位置

### 可选项（32位的倍数）
![image](2.tcp.assets/12607)
- **TimeStamp：** TCP 时间戳，其中 kind = 8， length = 10， info 有两部分构成: timestamp和timestamp echo，各占 4 个字节
- **MSS：** 指的是 TCP 允许的从对方接收的最大报文段
- **SACK：** 
    - SACK_Permitted 选项，该选项只允许在 TCP 连接建立时，有 SYN 标志的包中设置，也即 TCP 握手的前两个包中，分别表示通信的两方各自是否支持 SACK
    - SACK(选择性确认) 选项位于 Options 中。该选项参数告诉对方已经接收到并缓存的不连续的数据块，发送方可根据此信息检查究竟是哪些块丢失，从而发送相应的数据块。受 TCP 包长度限制，TCP 包头最多包含四组 SACK 字段
- **Window Scale：**  窗口缩放选项

#### 可选项中的时间戳

##### 计算RTT
- a 向 b 发送的时候，timestamp 中存放的内容就是 a 主机发送时的内核时刻 ta1
- b 向 a 回复 s2 报文的时候，timestamp 中存放的是 b 主机的时刻 tb, timestamp echo字段为从 s1 报文中解析出来的 ta1
- a 收到 b 的 s2 报文之后，此时 a 主机的内核时刻是 ta2, 而在 s2 报文中的 timestamp echo 选项中可以得到 ta1, 也就是 s2 对应的报文最初的发送时刻。然后直接采用 ta2 - ta1 就得到了 RTT 的值

##### 防止序列号回绕问题
- 每次发包的时候都是将发包机器当时的内核时间记录在报文中，那么两次发包序列号即使相同，时间戳也不可能相同，这样就能够区分开两个数据包了

## 三次握手

### 基本过程
![](2.tcp.assets/12609)
- **第一次握手：**
    - 客户端发送报文`SYN，seq=x`，进入`SYN_SEND`状态
    - 服务端收到报文，进入`LISTEN`状态
- **第二次握手：**
	- 服务端发送报文`SYN，ACK，seq=y，ack=x+1`， 进入`SYN_RCVD`状态
- **第三次握手：**
    - 客户端发送报文`ACK，seq=x+1，ack=y+1` 进入`Established`状态
    - 服务端收到报文，进入`Established`状态
    - 该次握手可以`携带数据发送`

### TFO（TCP快速打开）
![image](2.tcp.assets/12611)
- **首轮三次握手：** 
	- 第二次握手中，服务端通过计算得到一个`SYN Cookies`，返回给客户端
- **后面的三次握手：**
    - 客户端会将之前缓存的 Cookie、SYN 和HTTP请求发送给服务端，服务端验证了 Cookie 的合法性，如果不合法直接丢弃；如果是合法的，那么就正常返回SYN + ACK
    - 现在服务端能向客户端发 HTTP 响应了！这是最显著的改变，三次握手还没建立，仅仅验证了 Cookie 的合法性，就可以返回 HTTP 响应了
	- 三次握手的过程中，就可以进行HTTP请求和相应

### 为什么三次握手
- 客户端和服务端都需要知道对方的`发送能力`和`接收能力`正常
- 第一次握手，客户端确认了客户端的发送能力；服务端确认了客户端的发送能力、服务端的接收能力
- 第二次握手，客户端确认了客户端的接收能力、服务端的发送能力、服务端的接收能力；服务端确认了服务端的发送能力
- 第三次握手，服务端确认了客户端的接收能力
- 为了防止`已失效的链接请求报文`突然又传送到了服务端，因而产生错误
- 客户端发出的连接请求报文并未丢失，而是在某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间才到达Server。这是，Server误以为这是Client发出的一个新的链接请求，于是就向客户端发送确认数据包，同意建立链接。若不采用“三次握手”，那么只要Server发出确认数据包，新的链接就建立了。由于client此时并未发出建立链接的请求，所以其不会理睬Server的确认，也不与Server通信；而这时Server一直在等待Client的请求，这样Server就白白浪费了一定的资源。若采用“三次握手”，在这种情况下，由于Server端没有收到来自客户端的确认，则就会知道Client并没有要求建立请求，就不会建立链接

### SYN FLOOD

#### 半连接队列
- 当客户端发送SYN到服务端，服务端收到以后回复ACK和SYN，状态由LISTEN变为SYN_RCVD，此时这个连接就被推入了SYN队列，也就是半连接队列
- TCP重传机制默认重试5次，每次等待间隔为上一次的2倍（1+2+4+8+16+32），即`每一个半连接需要耗时63s才能释放`，TCP半连接队列默认为1024，`当队列满了之后，就会拒绝服务`

#### 全连接队列
- 当客户端返回ACK，服务端接收后，三次握手完成。这个时候连接等待被具体的应用取走，在被取走之前，它会被推入另外一个 TCP 维护的队列，也就是全连接队列(Accept Queue)

#### SYN Flood 攻击原理
- 就是用客户端在短时间内伪造大量不存在的 IP 地址，并`向服务端疯狂发送SYN`。对于服务端而言，会产生两个危险的后果:
    - 处理大量的SYN包并返回对应ACK，势必有大量连接处于SYN_RCVD状态，从而`占满整个半连接队列`，无法处理正常的请求
    - 由于是不存在的 IP，服务端长时间收不到客户端的ACK，会`导致服务端不断重发数据`，直到耗尽服务端的资源

#### 如何应对 SYN Flood 攻击
- 增加 SYN 连接，也就是增加半连接队列的容量
- 减少 SYN + ACK 重试次数，避免大量的超时重发
- 利用 SYN Cookie 技术，在服务端接收到SYN后不立即分配连接资源，而是根据这个SYN计算出一个Cookie，连同第二次握手回复给客户端，在客户端回复ACK的时候带上这个Cookie值，服务端验证 Cookie 合法之后才分配连接资源

## 四次挥手

### 基本过程
![](2.tcp.assets/12613)
- **第一次挥手：**
    - 客户端发送`FIN，seq=u`，进入`FIN_WAIT1`状态
    - 服务端收到报文，进入`CLOSE_WAIT`状态
- **第二次挥手：**
    - 服务端发送`ACK，seq=k，ack=u+1`
    - 客户端收到报文，进入`FIN_WAIT2`状态
    - 第二次与第三次挥手之间，服务端还可以发送数据给客户端
- **第三次挥手：**
    - 服务端发送`FIN，ACK，seq=w，ack=u+1`，进入`LAST_ACK`状态
    - 客户端收到报文，进入`TIME_WAIT`状态
- **第四次挥手 ：**
    - 客户端发送 `ACK ，seq=u+1 ，ack=w+1`，等待`2MSL`后，进入`CLOSED`状态
    - 服务端收到报文，进入`CLOSED`状态

### 为什么TIME_WAIT要等待2MSL（最大报文生存时间）
- 保证最后一个ACK能成功到达服务端（若在2MSL内收到服务端的重传报文，则会重置TIME_WAIT）
- 如果不等待2MSL，此时服务端还有数据发送给客户端，而客户端断开连接后新的连接又复用了旧端口，造成旧数据发送到新连接，数据混乱
- 处于TIME_WAIT状态的端口不能使用，会丢弃所有报文，此举可以保证下一个新的连接不会出现旧的连接请求的报文

### 为什么四次挥手
- TCP是全双工，为了`确保双方都没有数据发送给对方`
> 举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束

## 协议如何保证可靠传输
1. **数据分块：** 应用数据被分割成 TCP 认为最适合发送的数据块。
2. **对失序数据包重排序：** TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层
3. **校验和：** TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段 
4. **丢弃重复数据：** TCP 的接收端会丢弃重复的数据 
5. **流量控制：** TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用`滑动窗口`实现流量控制）
6. **拥塞控制：** 当网络拥塞时，减少数据的发送
7. **ARQ协议：** 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
8. **超时重传：** 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 

### ARQ协议

#### 停止等待ARQ协议
- 停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）
- 如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组
- 在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认
- **优点：** 简单
- **缺点：** 信道利用率低，等待时间长

#### 连续ARQ协议
- 连续 ARQ 协议可提高信道利用率
- 发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认
- 接收方一般采用累计确认，对`按序到达的最后一个分组`发送确认，表明到这个分组为止的所有分组都已经正确收到了
- **优点：** 信道利用率高，容易实现，即使确认丢失，也不必重传
- **缺点：** 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。

### 流量控制
- TCP 利用`滑动窗口`实现流量控制
- 流量控制是为了控制`发送方发送速率`，保证接收方来得及接收
- 接收方发送的确认报文中的`窗口字段`可以用来控制发送方窗口大小，从而影响发送方的发送速率
- 将窗口字段设置为 0，则发送方不能发送数据

### 拥塞控制
![image](2.tcp.assets/12617)

#### 慢开始
- 当 cwnd < ssthresh 时，使用慢开始
- 先发送一个1字节的试探报文，当收到确认后，就发送2个字节的报文，继而4个，8个以此指数类推

#### 拥塞避免
- 当 cwnd > ssthresh 时，使用拥塞避免算法
- 让拥塞窗口缓慢地增大，即cwnd每次加1

#### 当发生拥塞时
- 只要发送方没有收到确认，就认为这时候拥塞了
- 把慢开始门限ssthresh设置为此时发送方窗口值的一半（上例中是把发送方窗口值24修改为12）
- 把拥塞窗口cwnd重新设置为1，执行慢开始算法

#### 快重传
![image](2.tcp.assets/12619)
- 当发送方连续收到3个重复的ack时，就会触发快重传
- 快重传不需要等到重传定时器溢出就重新传递
- 如例子，发送方收到连续3个M2的重复ack，就会立即重传M3

#### 快恢复
- 当发送方连续收到三个重复确认，就把慢开始门限ssthresh减半
- 把cwnd值设置为门限ssthresh减半后的数值，然后开始执行的是拥塞避免算法，使拥塞窗口缓慢地线性增大

### 四个定时器

#### 重传定时器
- 每`发送一个报文段`就会启动重传定时器，假设在定时器时间到后还没收到对该报文段的确认，就重传该报文段，并将重传定时器复位，又一次计算
- 假设在规定时间内收到了对该报文段的确认，则撤销该报文段的重传定时器

##### TCP的超时重传时间(RTO)是如何计算的

###### 经典方法
- SRTT =  (α * SRTT) + ((1 - α) * RTT)
    - SRTT的初始值为0
    - α 是平滑因子，建议值是0.8，范围是0.8 ~ 0.9
- RTO = min(ubound, max(lbound, β * SRTT))
	- β 是加权因子，一般为1.3 ~ 2.0， lbound 是下界，ubound 是上界
- RTT对于RTO影响较少

###### 标准方法（Jacobson / Karels 算法）
- SRTT = (1 - α) * SRTT + α * RTT
    - SRTT的初始值为0
    - α 建议值是0.125
- RTTVAR = (1 - β) * RTTVAR + β * (|RTT - SRTT|)
	- β 建议值为 0.25
- RTO = µ * SRTT + ∂ * RTTVAR
	- µ建议值取1
	- ∂建议值取4
- 这个公式在 SRTT 的基础上加上了最新 RTT 与它的偏移，从而很好的感知了 RTT 的变化，这种算法下，RTO 与 RTT 变化的差值关系更加密切

#### 坚持定时器
- TCP连接的一方收到对方的`零窗体通知`，就启动坚持定时器
- 若坚持定时器设置的时间到期，就发送一个零窗体控測报文段（该报文段仅仅有一个字节的数据，它有一个序号，但该序号永远不须要确认，因此该序号能够持续重传），之后会出现下面三种情况：
    - 对方在收到探測报文段后，在对该报文段的确认中给出如今的窗体值，假设窗体值仍未零，则收到这个报文段的一方将坚持定时器的值加倍并重新启动。坚持计数器最大仅仅能添加到约60秒，在此之后，每次收到零窗体通知，坚持计数器的值就定位60秒
    - 对方在收到探測报文段后，在对该报文段的确认中给出如今的窗体值，假设窗体不为零，那么死锁的僵局就被打破了
    - 该探測报文发出后，会同一时候启动重传定时器，假设重传定时器的时间到期，还没有收到接收到发来的响应，则超时重传探測报文

#### 保活定时器
- `server每收到一次client的数据`，就又一次设置保活定时器，通常为2小时
- 假设2小时没有收到client的数据，服务端就发送一个探測报文，以后每隔75秒发送一次，假设连续发送10次探測报文段后仍没有收到client的响应，server就觉得client出现了故障，就能够`终止这个连接`


    // 每隔 7200 s 检测一次
    net.ipv4.tcp_keepalive_time = 7200
    // 一次最多重传 9 个包
    net.ipv4.tcp_keepalive_probes = 9
    // 每个包的间隔重传间隔 75 s
    net.ipv4.tcp_keepalive_intvl = 75

#### 2MSL定时器
-  2MSL定时器測量一个连接处于`TIME-WAIT`的时间，通常为2MSL（报文段寿命的两倍）

## Nagle 算法和延迟确认

### Nagle算法（延迟发送）
- 避免小包的频繁发送
- 当第一次发送数据时不用等待，就算是 1byte 的小包也立即发送
- 后面发送满足下面条件之一就可以发了:
    - 数据包大小达到最大段大小(Max Segment Size, 即 MSS)
    - 之前所有包的 ACK 都已接收到

### 延迟确认
- 确认的时候等待延迟的时延，把两个包的 ACK 合并后一起回复
- TCP 要求这个延迟的时延必须小于500ms，一般操作系统实现都不会超过200ms
- 有一些场景是不能延迟确认的，收到了就要马上回复:
    - 接收到了大于一个 frame 的报文，且需要调整窗口大小
    - TCP 处于 quickack 模式（通过tcp_in_quickack_mode设置）
    - 发现了乱序包




