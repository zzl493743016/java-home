## 请求报文
![image](4.http.assets/12628)

### 请求行
- 请求方法
- URI
- 协议版本

### 请求头部（Request Headers）

### 请求体（Request Body）

## 响应报文
![image](4.http.assets/12630)

### 响应行
- 协议版本
- 状态码
- 状态描述

### 响应头部（Response Headers）

### 响应体（Response Body）

## Get和Post区别
- Get的入参放URL后面，不同的浏览器对URL的长度定义不一，所以入参长度受浏览器限定影响
- Post的入参放Request Body里面，可能存在web服务器对post提交数据大小有限制
- Get主要用于查询，Post主要用于新建资源

## 状态码
- 200：请求被正常处理
- 204：请求被受理但没有资源可以返回
- 206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。
- 301：永久性重定向
- 302：临时重定向
- 303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上
- 304：客户端有缓冲的文档并发出了一个条件性的请求。服务器告诉客户端，原来缓冲的文档还可以继续使用
- 307：临时重定向，与302类似，只是强制要求使用POST方法
- 400：请求报文语法有误，服务器无法识别
- 401：请求需要认证
- 403：请求的对应资源禁止被访问
- 404：服务器无法找到对应资源
- 500：服务器内部错误
- 502：已经与后端建立了连接，但超时
- 503：服务器正忙
- 504：后端连接未建立，超时

## 不同版本的HTTP

### HTTP 1.0
- HTTP 1.0 仅仅提供了最基本的认证，这时候用户名和密码还未经加密，因此很容易收到窥探
- HTTP 1.0 被设计用来使用`短链接`，即每次发送数据都会经过 TCP 的三次握手和四次挥手，效率比较低
- HTTP 1.0 只使用 header 中的 If-Modified-Since 和 Expires 作为缓存失效的标准
- HTTP 1.0 `不支持断点续传`，也就是说，每次都会传送全部的页面和数据
- HTTP 1.0 认为每台计算机只能绑定一个 IP，所以请求消息中的 URL 并`没有传递主机名`（hostname）

### HTTP 1.1
- HTTP 1.1 使用了摘要算法来进行`身份验证`
- HTTP 1.1 `默认使用长连接`，长连接就是只需一次建立就可以传输多次数据，传输完成后，只需要一次切断连接即可（长连接的连接时长可以通过请求头中的 keep-alive 来设置）
- HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来`控制缓存失效`
- HTTP 1.1 `支持断点续传`，HTTP1.1则在请求头引入了`range`头域，它允许只请求资源的某个部分，即返回码是`206`（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接
- HTTP 1.1 使用了`虚拟网络`，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。
- 在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除

### HTTP 2.0
- `头部压缩`，由于 HTTP 1.1 经常会出现 User-Agent、Cookie、Accept、Server、Range 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。HTTP 2.0 使用 HPACK 算法进行压缩
- `二进制格式`，HTTP 2.0 使用了更加靠近 TCP/IP 的二进制格式，而抛弃了 ASCII 码，提升了解析效率
- `强化安全`，由于安全已经成为重中之重，所以 HTTP2.0 一般都跑在 `HTTPS` 上
- `多路复用`，即每一个请求都是是用作连接共享。`一个请求对应一个id`，这样一个连接上可以有多个请求

#### HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别
![image](4.http.assets/12632)
- HTTP/1.1 Pipeling解决方式为，若干个请求排队`串行化单线程`处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的`线头阻塞`
- HTTP/2多个请求可同时在一个连接上`并行执行`，某个请求任务耗时严重，不会影响到其它连接的正常执行

## HTTPS
![img](4.http.assets/17194b5a59afb4dc)

### 工作原理
![img](4.http.assets/17194b5a5a1b5f82)
- Client Hello  
	- Client发起HTTPS请求，连接到Server的443端口，发送`随机值1`、Client支持的`对称加密算法集合`和SSL Version等信息
- Server Hello 
	- Server发送`随机值2`和`一个加密算法`（从收到的加密算法集合中取）
- Certificate  
	- Server准备一套证书（可以自己生成or从CA机构获取），将`传送证书`发送给Client。证书主要包含私钥和公钥，而`传送证书`主要包含`公钥`，和各种其他信息，此过程主要用来将`公钥`传给Client
- Certificate Request（可选）
	- 是Server要求客户端上报证书，这一步是可选的，对于安全性要求高的场景会用到
- Server Hello Done
	- Server Hello Done 通知客户端 Server Hello 过程结束
- Certificate Verify
	- Client校验证书的合法性，如果没问题，则会生成`随机值3`，然后用`公钥`加密得到`预主密钥`
- Client Key Exchange
	- Client将预主密钥传给服务端，服务端根据私钥解密，得到`随机值3`。现在Client和Server都拥有`随机值1`、`随机值2`、`随机值3`，两边根据协商的`对称加密算法`，生成`会话密钥`
- Encrypted Handshake Message
	- Client通过`会话密钥`和协商好的`对称加密算法`，加密一条信息发送到Server，验证Server能否正常接收Client的数据
- Encrypted Handshake Message
	- Server通过`会话密钥`和协商好的`对称加密算法`，加密一条信息回传到Client，如果Client能正常接收，表示SSL连接建立成功

### 中间人攻击
- 挟持请求，使流量都导向中间人
- Client发送HTTPS连接请求，会先与中间人建立SSL连接
- 中间人主动与Server建立SSL连接
- 当Client向Server发送请求时，中间人从Client获得具体请求信息后，重新包装，再发送给Server
- 当Server向Client回传时，中间人从Server获得回传信息后，重新包装，再回传给Client

### HTTPS如何防止中间人攻击
- CA机构根据证书内容，先通过`签名计算方法`得到`信息摘要`，然后用`私钥`加密得到`数字签名`
- CA机构使用`公钥`，对`Server公钥`、`权威机构的信息`、`Server域名`、`签名计算方法`、`证书对应的域名`和`数字签名`进行对称加密
- Client收到证书后，会使用配置在本地的权威机构的`公钥`对证书进行对称解密，获得`Server公钥`和证书的`数字签名`，然后使用`Server公钥`解密`数字签名`，可以获得证书的`信息摘要`
- Client通过证书`签名计算方法`，计算一下当前证书的`信息摘要`，然后与解密得到的`信息摘要`进行对比，如果一致，说明证书没有被篡改
- 中间人虽然可以篡改证书内容，但是由于其没有`私钥`，不能重新对证书内容进行加密，会导致Client解密的时候，证书验证不通过
- 中间人虽然可以从网上获取一些公开的证书用来通过证书验证，但是由于其没有私钥，所以也不能对Client发送的密文进行解密
