## 请求报文
![image](4.http.assets/12628)

### 请求行
- 请求方法
- URI
- 协议版本

### 请求头部（Request Headers）

### 请求体（Request Body）

## 响应报文
![image](4.http.assets/12630)

### 响应行
- 协议版本
- 状态码
- 状态描述

### 响应头部（Response Headers）

### 响应体（Response Body）

## Get和Post区别
- Get的入参放URL后面，不同的浏览器对URL的长度定义不一，所以入参长度受浏览器限定影响
- Post的入参放Request Body里面，可能存在web服务器对post提交数据大小有限制
- Get主要用于查询，Post主要用于新建资源

## 状态码
- 200：请求被正常处理
- 204：请求被受理但没有资源可以返回
- 206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。
- 301：永久性重定向
- 302：临时重定向
- 303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上
- 304：客户端有缓冲的文档并发出了一个条件性的请求。服务器告诉客户端，原来缓冲的文档还可以继续使用
- 307：临时重定向，与302类似，只是强制要求使用POST方法
- 400：请求报文语法有误，服务器无法识别
- 401：请求需要认证
- 403：请求的对应资源禁止被访问
- 404：服务器无法找到对应资源
- 500：服务器内部错误
- 502：已经与后端建立了连接，但超时
- 503：服务器正忙
- 504：后端连接未建立，超时

## 不同版本的HTTP

### HTTP1.1和HTTP1.0
- 更多的缓存处理
    - 在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略
- 带宽优化及网络连接的使用（断点续传）
    - HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接
- 错误通知的管理
    - 在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除
- Host头处理
    - 在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）
- 默认长连接
    - HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点

### HTTP1.x和HTTP1.0
- 降低延迟（多路复用）
    - 针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率
- 请求优先级（request prioritization）
    - 多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容
- header压缩
    - 前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量
- 基于HTTPS的加密协议传输
	- 大大提高了传输数据的可靠性
- 服务端推送（server push）
    - 采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了

### HTTP2.0和HTTP1.X
- 新的二进制格式（Binary Format）
    - HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮
- 多路复用（MultiPlexing）
    - 即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面
- header压缩
    - HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小
- 服务端推送（server push）
	- 同SPDY一样，HTTP2.0也具有server push功能

### HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别
![image](4.http.assets/12632)
- HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接
- HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞
- HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行

## HTTPS

### 工作原理
- Client Hello  
	- Client发起HTTPS请求，连接到Server的443端口，发送`随机值1`、Client支持的`对称加密算法集合`和SSL Version等信息
- Server Hello 
	- Server发送`随机值2`和`一个加密算法`（从收到的加密算法集合中取）
- Certificate  
	- Server准备一套证书（可以自己生成or从CA机构获取），将`传送证书`发送给Client。证书主要包含私钥和公钥，而`传送证书`主要包含`公钥`，和各种其他信息，此过程主要用来将`公钥`传给Client
- Certificate Request（可选）
	- 是Server要求客户端上报证书，这一步是可选的，对于安全性要求高的场景会用到
- Server Hello Done
	- Server Hello Done 通知客户端 Server Hello 过程结束
- Certificate Verify
	- Client校验证书的合法性，如果没问题，则会生成`随机值3`，然后用`公钥`加密得到`预主密钥`
- Client Key Exchange
	- Client将预主密钥传给服务端，服务端根据私钥解密，得到`随机值3`。现在Client和Server都拥有`随机值1`、`随机值2`、`随机值3`，两边根据协商的`对称加密算法`，生成`会话密钥`
- Encrypted Handshake Message
	- Client通过`会话密钥`和协商好的`对称加密算法`，加密一条信息发送到Server，验证Server能否正常接收Client的数据
- Encrypted Handshake Message
	- Server通过`会话密钥`和协商好的`对称加密算法`，加密一条信息回传到Client，如果Client能正常接收，表示SSL连接建立成功

### 中间人攻击
- 挟持请求，使流量都导向中间人
- Client发送HTTPS连接请求，会先与中间人建立SSL连接
- 中间人主动与Server建立SSL连接
- 当Client向Server发送请求时，中间人从Client获得具体请求信息后，重新包装，再发送给Server
- 当Server向Client回传时，中间人从Server获得回传信息后，重新包装，再回传给Client

### HTTPS如何防止中间人攻击
- CA机构根据证书内容，先通过`签名计算方法`得到`信息摘要`，然后用`私钥`加密得到`数字签名`
- CA机构使用`公钥`，对`Server公钥`、`权威机构的信息`、`Server域名`、`签名计算方法`、`证书对应的域名`和`数字签名`进行对称加密
- Client收到证书后，会使用配置在本地的权威机构的`公钥`对证书进行对称解密，获得`Server公钥`和证书的`数字签名`，然后使用`Server公钥`解密`数字签名`，可以获得证书的`信息摘要`
- Client通过证书`签名计算方法`，计算一下当前证书的`信息摘要`，然后与解密得到的`信息摘要`进行对比，如果一致，说明证书没有被篡改
- 中间人虽然可以篡改证书内容，但是由于其没有`私钥`，不能重新对证书内容进行加密，会导致Client解密的时候，证书验证不通过
- 中间人虽然可以从网上获取一些公开的证书用来通过证书验证，但是由于其没有私钥，所以也不能对Client发送的密文进行解密
