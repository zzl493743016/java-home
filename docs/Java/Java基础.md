## 1.面向对象和面向过程的区别

- **面向过程** ：**面向过程性能比面向对象高。** 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，**面向过程没有面向对象易维护、易复用、易扩展**
- **面向对象** ：**面向对象易维护、易复用、易扩展。** 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，**面向对象性能比面向过程低**

### 1.1  面向过程 ：面向过程性能比面向对象高？？[详细参见](https://github.com/Snailclimb/JavaGuide/issues/431)

- 这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码
- 而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比  Java 好

## 2. Java 语言有哪些特点?

- 简单易学
- 面向对象（封装，继承，多态）
- 平台无关性（ Java 虚拟机实现平台无关性）
- 可靠性
- 安全性
- 支持多线程（C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用`std::thread`和`std::async`来创建线程）
- 支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）
- 编译与解释并存


## 3. 关于 JVM、 JDK 和 JRE 最详细通俗的解答

### 3.1 JVM

#### 3.1.1 什么是JVM

- Java 虚拟机（JVM）是运行 Java 字节码的虚拟机
- JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果

#### 3.1.2 什么是字节码?采用字节码的好处是什么?

- 在 Java 中，JVM 可以理解的代码就叫做`字节码`（即扩展名为 `.class` 的文件），它不面向任何特定的处理器，只面向虚拟机
- Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行

#### 3.1.3 Java 程序从源代码到运行的三大步骤

![Java程序运行过程](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java%20%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png)

#### 3.1.4 JIT

- 我们需要格外注意的是 `.class->机器码` 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的`热点代码`)，所以后面引进了 JIT 编译器，而 JIT 属于`运行时编译`
- 当 JIT 编译器完成第一次编译后，其会将字节码对应的`机器码`保存下来，下次可以`直接使用`。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言

- HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据`二八定律`，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分

- JVM 会根据代码每次被执行的情况收集信息并相应地做出一些`优化`，因此执行的次数越多，它的速度就越快

#### 3.1.5 AOT

- JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是`直接将字节码编译成机器码`，这样就`避免了 JIT 预热等各方面的开销`。JDK 支持分层编译和 AOT 协作使用
- AOT 编译器的编译质量是肯定比不上 JIT 编译器的

### 3.2 JDK 和 JRE

- JDK 是 Java Development Kit，它是`功能齐全的 Java SDK`。它`拥有 JRE 所拥有的一切`，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序

- JRE 是 Java `运行时环境`。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序

> 如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet

## 4. Oracle JDK 和 OpenJDK 的对比

- Oracle JDK 大概每 6 个月发一次主要版本，而 OpenJDK 版本大概每三个月发布一次。但这不是固定的，我觉得了解这个没啥用处
- OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的
- Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题
- 在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能
- Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本
- Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可

## 5. Java 和 C++的区别

- 都是面向对象的语言，都支持封装、继承和多态
- Java 不提供指针来直接访问内存，程序内存更加安全
- Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。
- Java 有自动内存管理机制，不需要程序员手动释放无用内存
- **在 C 语言中，字符串或字符数组最后都会有一个额外的字符‘\0’来表示结束。但是，Java 语言中没有结束符这一概念。** 这是一个值得深度思考的问题，具体原因推荐看这篇[文章](https://blog.csdn.net/sszgg2006/article/details/49148189)

## 6. 什么是 Java 程序的主类？应用程序和小程序的主类有何不同

- 一个程序中可以有多个类，但只能有一个类是主类
- 在 Java 应用程序中，这个主类是指包含 main（）方法的类
- 而在 Java 小程序中，这个主类是一个继承自系统类 JApplet 或 Applet 的子类
- 应用程序的主类不一定要求是 public 类，但小程序的主类要求必须是 public 类
- 主类是 Java 程序执行的入口点

## 7. Java 应用程序与小程序之间有哪些差别

- 简单说应用程序是从主线程启动(也就是 `main()` 方法)
- applet 小程序没有 `main()` 方法，主要是嵌在浏览器页面上运行(调用`init()`或者`run()`来启动)，嵌入浏览器这点跟 flash 的小游戏类似

## 8. 字符型常量和字符串常量的区别

- 形式上：字符常量是`单引号`引起的`一个`字符; 字符串常量是`双引号`引起的`若干个`字符
- 含义上：字符常量相当于一个`整型值`( ASCII 值),可以参加表达式运算; 字符串常量代表一个`地址值`(该字符串在内存中存放位置)
- 占内存大小：字符常量只占` 2 个字节`; 字符串常量占`若干个字节` (**注意： char 在 Java 中占两个字节**)

## 9. 构造器 Constructor


### 9.1 一个类的构造方法的作用是什么

- 主要作用是完成对类对象的初始化工作

### 9.2 若一个类没有声明构造方法，该程序能正确执行吗? 为什么

- 可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法

### 9.3 构造方法有哪些特性？

- 名字与类名相同
- 没有返回值，但不能用 void 声明构造函数
- 生成类的对象时自动执行，无需调用

### 9.4 是否可被 override(重载)

- 不能被 override（重写）
- 可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况

### 9.5 在 Java 中定义一个不做事且没有参数的构造方法的作用

- Java 程序在执行子类的构造方法之前，如果没有用 `super()`来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”
- 如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 `super()`来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行
- 解决办法是在父类里加上一个不做事且没有参数的构造方法

### 9.6 在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?

- 帮助子类做初始化工作

## 10. Override(重载)和Overload(重写)的区别

### 10.1 Override(重载)

- 重载就是`同一个类`中多个`同名方法`根据`不同的传参`来执行不同的逻辑处理

### 10.2 Overload(重写)

- 重写发生在`运行期`，是`子类`对`父类`的允许访问的方法的实现过程进行重新编写
- `返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类`

## 11. Java 面向对象编程三大特性: 封装 继承 多态

### 11.1 封装

- 封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了

### 11.2 继承

- 继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码

#### 11.2.1 关于继承如下 3 点请记住：

- 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，`只是拥有`
- 子类可以拥有自己属性和方法，即子类可以对父类进行扩展
- 子类可以用自己的方式实现父类的方法

### 11.3 多态

- 所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定
- 在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）

## 12. String、StringBuffer 和 StringBuilder

### 12.1 区别

#### 12.1.1 可变性
- 使用 final 关键字修饰字符数组来保存字符串，`private final char value[]`，所以 String 对象是`不可变`的
- 而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串`char[]value` 但是没有用 final 关键字修饰，所以这两种对象都是`可变`的
> 在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 `private final byte[] value`

#### 12.1.2 线程安全性

- String 中的对象是不可变的，也就可以理解为`常量`，`线程安全`
- StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是`线程安全`的
- StringBuilder 并没有对方法进行加同步锁，所以是`非线程安全`的
> AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法

#### 12.1.3 性能

- 每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象
- StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用
- 相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险

### 12.2 String

#### 12.2.1 创建方式

> 引号创建`String a = "a"`

- 在方法区的字符串池中，创建字符串常量
- 引用指向字符串常量

> new创建（不推荐使用）`String a = new String("a")`

- 首先查看字符串池中是否有相同值的字符串
- 如果池中没有，则在字符串池中创建字符串常量
- 在堆中新建一个String实例，该实例指向字符串常量
- 引用指向堆中的String实例

#### 12.2.2 大量使用连接符+的问题

- 创建大量临时的StringBuilder对象，对字符串进行append操作
- 每次append操作完成后，调用toString方法将其转换成字符串
- 会频繁触发young gc

### 12.3 对于三者使用的总结

- 操作少量的数据: 适用 String
- 单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder
- 多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer

## 13. 基本数据类型与包装类

### 13.1 空间大小与对应关系

- byte（1字节）	Byte
- short（2字节）	Short
- char（2字节）	Character
- int（4字节）	Integer
- long（8字节）	Long
- float（4字节）	Float
- double（8字节）	Double
- boolean（未定）	Boolean

#### 13.1.1 boolean 占用空间大小

- java规范中，没有明确指出boolean的大小。在《Java虚拟机规范》给出了4个字节，和boolean数组1个字节的定义，`具体还要看虚拟机实现是否按照规范来`，所以1个字节、4个字节都是有可能的

### 13.2 装箱与拆箱 [深入剖析Java中的装箱和拆箱](https://www.cnblogs.com/dolphin0520/p/3780005.html)

- `装箱`：通过调用包装器的`valueOf`方法实现的
- `拆箱`：通过调用包装器的` xxxValue`方法实现的

#### 13.2.1 ==和equals

- 当 "=="运算符的两个操作数都是 包装器类型的引用，则是比较指向的是否是`同一个对象`，而如果其中有一个操作数是表达式（即包含算术运算）则`比较的是数值`（即会触发自动拆箱的过程）
- equals会先对比是否同一个类型，然后再用==进行数值对比

#### 13.2.2 整形、非整形和Boolean的不同实现

- 整形（Integer、Short、Byte、Character、Long）的实现，`-127~128`的数值，在拆装箱的时候会存取同一数值的`缓存对象`
- 非整形（Double、Float）`不会有缓存`
- Boolean的实现

        public static Boolean valueOf(boolean b) {
            return (b ? TRUE : FALSE);
        }

## 14. 静态方法和实例方法

### 14.1 区别

- 在外部调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方式。而实例方法只有后面这种方式。也就是说，调用`静态方法可以无需创建对象`
- 静态方法在访问本类的成员时，`只允许访问静态成员`（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制

### 14.2 在一个静态方法内调用一个非静态成员为什么是非法的?

- 由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员

## 15. import java 和 javax 有什么区别？

- 刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来使用。然而随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准 API 的一部分
- 实际上 java 和 javax 没有区别。这都是一个名字

## 16. interface（接口）和abstract（抽象类）

### 16.1 interface（接口）

- 不能实例化
- 一个类可以实现（implements）多个接口
- 变量：定义的变量都会被隐式修饰为`public static final`
- 方法：定义的方法都会被隐式修饰为`public abstract`，可以使用`静态方法`

### 16.2 abstrace（抽象类）

- 不能实例化
- 一个类只能实现（extends）一个抽象类
- 变量和方法：可以随便定义使用
- 抽象方法：不能是`private`，不能有具体实现

## 17. 成员变量与局部变量的区别

### 17.1 语法形式

- 成员变量是属于`类`的，而局部变量是在`方法`中定义的变量或是方法的参数
- 成员变量可以被 public,private,protect,default,static 等`修饰符`所修饰，而局部变量不能
- 成员变量和局部变量都能被 `final` 所修饰

### 17.2 在内存中的存储方式

- 如果成员变量是使用`static`修饰的，那么这个成员变量是`属于类`的，如果没有使用`static`修饰，这个成员变量是`属于实例`的，对象存于堆内存
- 如果局部变量类型为基本数据类型，那么存储在`栈内存`，如果为引用数据类型，那存放的是`指向堆内存对象的引用`或者是`指向常量池中的地址`

### 17.3 在内存中的生存时间

- 成员变量是对象的一部分，它`随着对象的创建`而存在
- 局部变量`随着方法的调用`而自动消失

### 17.4 赋值形式

- 成员变量如果没有被赋初值:则会`自动以类型的默认值`而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值）
- 局部变量则`不会自动赋值`

## 18. 创建一个对象用什么运算符?对象实体与对象引用有何不同?

- new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）
- 一个对象引用可以指向 0 个或 1 个对象，一个对象可以有 n 个引用指向它

## 19. == 与 equals

### 19.1 ==

- 它的作用是判断两个对象的地址是不是相等，即，判断两个对象是不是同一个对象
- 基本数据类型==比较的是值，引用数据类型==比较的是内存地址

### 19.2 equals

- 类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象
- 类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)

### 19.3 关于String的equals

- String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是只比较的对象的内存地址，而 String 的 equals 方法是先比较内存地址，如果地址不同，则比较具体的值

## 20. hashCode 与 equals

### 20.1 hashCode（）

- hashCode() 的作用是获取哈希码，也称为`散列码`；它实际上是返回一个 `int 整数`
- 这个哈希码的作用是确定该对象在`哈希表中的索引位置`
- hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的`任何类都包含`有 hashCode() 函数
- 散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”，这其中就利用到了散列码！（`可以快速找到所需要的对象`）

### 20.2 为什么要有 hashCode

- 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与该位置其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现
- 但是如果发现有相同 hashcode 值的对象，这时会调用 `equals()`方法来检查 hashcode 相等的对象是否真的相同
- 如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置
- 这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度

### 20.3 hashCode（）与 equals（）的相关规定

- 两个对象相等，调用 equals 方法必须返回 true
- 两个对象相等，则 hashcode 一定是相同的
- 两个对象有相同的 hashcode，两个对象不一定相等

### 20.4 为什么重写equals（）必须也重写hashCode（）

- 如果没有重写hashCode（），则会出现调用equals返回true，但是hashcode不相同的情况
- 当放入散列表（HashMap or HashSet）的时候，就会出现重复的key

## 21.  Java 的值传递

- 当入参为基本数据类型时，复制值
- 当入参为引用类型时，复制指针


## 22 关于 final 关键字的一些总结

final 关键字主要用在三个地方：变量、方法、类。

1. 对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
2. 当用 final 修饰一个类时，表明这个类不能被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。
3. 使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。类中所有的 private 方法都隐式地指定为 final。

## 23 异常处理

### 23.1  Java 异常类层次结构图

![Java异常类层次结构图](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/Exception.png)

- 在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 `Throwable 类`
- Throwable： 有两个重要的子类：`Exception（异常）` 和 `Error（错误）` ，二者都是 Java 异常处理的重要子类，各自都包含大量子类
- 注意：异常和错误的区别：`异常能被程序本身处理，错误是无法处理`

### 23.2 Error

- 是程序无法处理的错误，表示运行应用程序中较严重问题
- 大多数错误与代码编写者执行的操作无关，而表示代码运行时` JVM（Java 虚拟机）出现的问题`（例如，Java 虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError）
- 这些异常发生时，Java 虚拟机（JVM）一般会选择`线程终止`
- 这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如 Java 虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java 中，错误通过 Error 的子类描述。

### 23.3 Exception

- 是程序本身可以处理的异常
- Exception 类有一个重要的子类 **RuntimeException**。RuntimeException 异常由 Java 虚拟机抛出
- **NullPointerException**（要访问的变量没有引用任何对象时，抛出该异常）、**ArithmeticException**（算术运算异常，一个整数除以 0 时，抛出该异常）和 **ArrayIndexOutOfBoundsException** （下标越界异常）。

### 23.4 Throwable 类常用方法

- **public string getMessage()**:返回异常发生时的简要描述
- **public string toString()**:返回异常发生时的详细信息
- **public string getLocalizedMessage()**:返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage（）返回的结果相同
- **public void printStackTrace()**:在控制台上打印 Throwable 对象封装的异常信息

### 23.5 异常处理总结

- **try 块：** 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块
- **catch 块：** 用于处理 try 捕获到的异常
- **finally 块：** 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return语句时，finally 语句块将在`方法返回之前被执行`
- 如果try，finally语句里均有return，`忽略try的return，而使用finally的return`

#### 23.5.1 在以下 4 种特殊情况下，finally 块不会被执行

1. 在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行
2. 在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行
3. 程序所在的线程死亡
4. 关闭 CPU

## 24 Java 序列化中如果有些字段不想进行序列化，怎么办

- 对于不想进行序列化的变量，使用 transient 关键字修饰
- transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法


## 25 Java 中 IO 流

### 25.1  Java 中 IO 流分为几种?

- 按照流的流向分，可以分为输入流和输出流
- 按照操作单元划分，可以划分为字节流和字符流
- 按照流的角色划分为节点流和处理流
- InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流
- OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流

#### 25.1.1 按操作方式分类结构图

![IO-操作方式分类](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/IO-操作方式分类.png)

#### 25.1.2 按操作对象分类结构图

![IO-操作对象分类](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/IO-操作对象分类.png)

### 25.2 不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？

- 字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作
- 如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好

### 25.3 BIO,NIO,AIO

#### 25.3.1 BIO

- 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机 1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量

#### 25.3.2 NIO

- NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 `Socket` 和 `ServerSocket` 相对应的 `SocketChannel` 和 `ServerSocketChannel` 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发

#### 25.3.3 AIO

- AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了

## 26. 常见关键字总结:static,final,this,super

详见笔主的这篇文章:  https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/basic/final,static,this,super.md

## 27. Collections 工具类和 Arrays 工具类常见方法总结

详见笔主的这篇文章:  [https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/basic/Arrays,CollectionsCommonMethods.md](https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/basic/Arrays,CollectionsCommonMethods.md)

## 28. 深拷贝 vs 浅拷贝

1. **浅拷贝**：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。
2. **深拷贝**：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。

![deep and shallow copy](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/java-deep-and-shallow-copy.jpg)


