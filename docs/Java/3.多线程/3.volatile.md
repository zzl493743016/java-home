## Java内存模型
![image](3.volatile.assets/12546)
- 每个线程创建时JVM都会为其创建一个工作内存(有些地方称为`栈空间`)，用于存储线程私有的数据
- 主内存是共享内存区域，所有线程都可以访问
- 线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存
- 线程间的通信(传值)必须通过主内存来完成

### 并发编程的三个重要特性
- **原子性 :**  一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行（synchronized ）
- **可见性 ：** 当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值（volatile，synchronized和final）
- **有序性 ：** 代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序（volatile，synchronized）

### happens-before
- **程序次序规则：** 在一个线程内一段代码的执行结果是有序的。就是还会指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变
- **管程锁定规则：** 就是无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果！(管程是一种通用的同步原语,synchronized就是管程的实现）
- **volatile变量规则：** 就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作的结果一定对读的这个线程可见
- **线程启动规则：** 在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见
- **线程终止规则：** 在主线程A执行过程中，子线程B终止，那么线程B在终止之前对共享变量的修改结果在线程A中可见
- **线程中断规则：** 对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()检测到是否发生中断
- **传递规则：** 这个简单的，就是happens-before原则具有传递性，即A happens-before B , B happens-before C，那么A happens-before C
- **对象终结规则：** 这个也简单的，就是一个对象的初始化的完成，也就是构造函数执行的结束一定 happens-before它的finalize()方法

## Volatile

### 原理
- 对于volatile变量，当对volatile变量进行写操作的时候，JVM会向处理器发送一条`lock`前缀的指令，将这个缓存中的变量`回写到系统主存`中
- 其他处理器的缓存由于遵守了`缓存一致性协议`，也会把这个变量的值从主存加载到自己的缓存中，这就保证了一个volatile在并发编程中，其值在多个缓存中是可见的
> 缓存一致性协议：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会`强制重新从系统内存里把数据读到处理器缓存里`

### 说 synchronized 关键字和 volatile 关键字的区别
- **有序性：** volatile通过`禁止指令重排`，synchronized通过将线程运行编排成`串行`执行
- **原子性：** volatile不支持，synchronized支持
- **可见性：** volatile支持，synchronized支持（通过unlock，线程解锁后必须先把变量回存到主内存）


