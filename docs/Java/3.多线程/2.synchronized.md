## 同步概念
### 对象
![对象](2.synchronized.assets/12519)
- **实例数据：** 存放类的属性数据信息，包括父类的属性信息
- **对齐填充：** 由于虚拟机要求 对象起始地址必须是`8字节的整数倍`，填充数据不是必须存在的，仅仅是为了字节对齐
- **对象头：** Java对象头一般占有2个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit，在64位虚拟机中，1个机器码是8个字节，也就是64bit），但是 如果对象是数组类型，则需要3个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度

### 对象头
![对象头](2.synchronized.assets/12521)
- **Class Pointer：** 是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例
- **Mark Word：** 用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键
- **Array Length：** 数组长度

### Mark Word
![Mark Word](2.synchronized.assets/12523)

### 线程中的Lock Record
- **Owner：** 初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL
- **EntryQ：** 关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程
- **RcThis：** 表示blocked或waiting在该monitor record上的所有线程的个数
- **Nest：** 用来实现 重入锁的计数
- **HashCode：** 保存从对象头拷贝过来的HashCode值（可能还包含GC age）
- **Candidate：** 用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁

### Monitor
    ObjectMonitor() {
        _header       = NULL;
        _count        = 0; // 记录个数
        _waiters      = 0,
        _recursions   = 0;
        _object       = NULL;
        _owner        = NULL;
        _WaitSet      = NULL; // 处于wait状态的线程，会被加入到_WaitSet
        _WaitSetLock  = 0 ;
        _Responsible  = NULL ;
        _succ         = NULL ;
        _cxq          = NULL ;
        FreeNext      = NULL ;
        _EntryList    = NULL ; // 处于等待锁block状态的线程，会被加入到该列表
        _SpinFreq     = 0 ;
        _SpinClock    = 0 ;
        OwnerIsThread = 0 ;
      }
- Monitor对象存在于每个Java对象的对象头`Mark Word`中（存储的指针的指向）
- ObjectMonitor中有两个队列，`_WaitSet` 和` _EntryList`，用来保存ObjectWaiter对象列表（ `每个等待锁的线程都会被封装成ObjectWaiter对象` ），_owner指向持有ObjectMonitor对象的线程
- 当多个线程同时访问一段同步代码时，会先存放到 `_EntryList` 集合中，接下来当线程获取到对象的monitor时，就会把`_owner`变量设置为当前线程，同时`count`变量+1
- 如果线程调用`wait()` 方法，就会释放当前持有的monitor，那么`_owner`变量就会被置为`null`，同时`_count`减1，并且该线程进入`_WaitSet`集合中，等待下一次被唤醒
- 若当前线程顺利执行完方法，将释放monitor，也就是`_owner`变量就会被置为`null`，同时`_count`减1




## synchronized 关键字的底层原理
### synchronized 同步语句块
![synchronized关键字原理](2.synchronized.assets/12514)
- **monitorenter：** 线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：
> - 如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者
> - 如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1（`可重入`）
> - 如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权

- **monitorexit：** 执行monitorexit的线程必须是objectref所对应的monitor的所有者
> - 指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者
> - 其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权

- monitorexit指令出现了两次，第1次为同步正常退出释放锁，第2次为发生异步退出释放锁

### synchronized 修饰方法的的情况
![synchronized关键字原理](2.synchronized.assets/12517)
- 当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor
- 在方法执行期间，其他任何线程都无法再获得同一个monitor对象

## 锁优化
### 自旋锁
- 当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直`循环检测`锁是否被释放，而不是进入线程挂起或睡眠状态
- 自旋锁适用于锁保护的临界区很小的情况，临界区很小的话，锁占用的时间就很短
- 自旋等待不能替代阻塞，虽然它可以避免线程切换带来的开销，但是它`占用了CPU处理器的时间`
- 如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费
- 所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起
- 自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用-XX:+UseSpinning开开启，在JDK1.6中默认开启。同时自旋的默认次数为`10`次，可以通过参数`-XX:PreBlockSpin`来调整

### 自适应自选锁
- 自旋的`次数不再是固定`的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定
- 线程如果`自旋成功`了，那么下次`自旋的次数会更加多`，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多
- 反之，如果对于某个锁，`很少有自旋能够成功`，那么在以后要或者这个锁的时候自旋的次数会`减少甚至省略掉自旋过程`，以免浪费处理器资源

### 锁消除
- JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除
- 锁消除的依据是`逃逸分析`的数据支持

### 锁粗化
- 将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁

### 锁升级
#### 综述
- 锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁
- 锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级

#### 无锁
![image](2.synchronized.assets/12533)
- 开始时应该这样的，线程A和线程B要去争抢锁对象，但还未开始争抢，锁对象的对象头是无锁的状态也就是25bit位存的hashCode，4bit位存的对象的分代年龄，1bit位记录是否为偏向锁，2bit位记录状态，优先看最后2bit位，是01，所以说我们的对象可能无锁或者偏向锁状态的，继续前移一个位置，有1bit专门记录是否为偏向锁的，1代表是偏向锁，0代表无锁，刚刚开始的时候一定是一个无锁的状态

#### 偏向锁
- 这时线程开始占有锁对象，比如线程A得到了锁对象
![image](2.synchronized.assets/12536)
- 就会变成这样的，线程A拿到锁对象，将我们的偏向锁标志位改为1，并且将原有的hashCode的位置变为23bit位存放线程A的线程ID（用CAS算法得到的线程A的ID），2bit位存epoch，`偏向锁是永远不会被释放的`
- 接下来，线程B也开始运行，线程B也希望得到这把锁啊，于是线程B会检查23bit位存的是不是自己的线程ID，因为被线程A已经持有了，23bit位一定不是线程B的线程ID了
![image](2.synchronized.assets/12538)
- 然后线程B也会不甘示弱啊，会尝试通过`CAS`修改一次23bit位的对象头存储，如果说这时恰好线程A释放了锁，可以修改成功，然后线程B就可以持有该偏向锁了。如果修改失败，开始升级锁。自己无法修改，线程B只能找“大哥”了，线程B会通知虚拟机撤销偏向锁，然后虚拟机会撤销偏向锁，并告知线程A到达安全点进行等待。线程A到达了安全点，会再次判断线程是否已经退出了同步块，如果退出了，将23bit位置空，这时锁不需要升级，线程B可以直接进行使用了，还是将23bit的null改为线程B的线程ID就可以了
![image](2.synchronized.assets/12540)

#### 轻量级锁
- 如果线程B没有拿到锁，我们就会升级到轻量级锁，首先会在线程A和线程B都开辟一块LockRecord空间，然后把锁对象复制一份到自己的LockRecord空间下，并且开辟一块owner空间留作执行锁使用，并且锁对象的前30bit位合并，等待线程A和线程B来通过`CAS`修改指向自己的线程，假如线程A修改成功，则锁对象头的前30bit位会存线程A的LockRecord的内存地址，并且线程A的owner也会存一份锁对象的内存地址，形成一个双向指向的形式。而线程B修改失败，则进入一个自旋状态，就是持续来修改锁对象
![image](2.synchronized.assets/12542)

#### 重量级锁
- 如果说线程B多次自旋以后还是迟迟没有拿到锁，他会继续上告，告知虚拟机，我多次自旋还是没有拿到锁，这时我们的线程B会`由用户态切换到内核态`，申请一个monitor，并且将锁对象的前30bit指向我们的monitor地址，并且进入`睡眠状态`，然后我们的线程A继续运行知道完成时，当线程A想要释放锁资源时，发现原来锁的前30bit位并不是指向自己了，这时线程A释放锁，并且去`唤醒所有处于睡眠状态的线程`，锁升级到重量级锁
![image](2.synchronized.assets/12544)

#### 为什么升级为轻量级锁时要把对象头里的Mark Word复制到线程栈的锁记录中呢
- 获取锁和释放锁，都需要使用Mark Word的信息作为CAS的比较条件
- 释放锁的CAS失败，说明锁已经升级为重量锁，需要唤醒被挂起的线程

#### 锁的优劣
##### 偏向锁
- **优点：** 同一线程的加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距
- **缺点：** 如果线程间存在锁竞争，会带来额外的锁撤销消耗
- **适用场景：** 只有一个线程访问同步块的场景

##### 轻量级锁
- **优点：** 竞争的线程不会阻塞，提高了程序的响应时间
- **缺点：** 获取不了锁的线程会自旋，消耗cpu
- **适用场景：** 同步代码块执行速度快，追求程序响应时间

##### 重量级锁
- **优点：** 线程竞争不使用自旋，不会消耗cpu
- **缺点：** 线程阻塞，程序响应慢
- **适用场景：** 同步代码块执行速度慢，追求吞吐量

## synchronized关键字最主要的三种使用方式
- **修饰实例方法:** 对`实例对象`加锁，进入同步实例方法前要获得当前实例对象的锁
- **修饰静态方法:** 对`类对象`加锁，进入同步静态方法前要获得当前类对象的锁
- **修饰代码块:** 对`指定对象`加锁（类对象 or 实例对象），进入同步代码块前要获得指定对象的锁

### 一个对象在两个线程中分别调用一个同步静态方法和一个同步实例方法，是否会互斥
- 虽然是一个对象调用，但是两个方法的锁类型不同，调用静态方法实际上是对`类对象`在调用，而调用实例方法实际上是对`实例对象`在调用，所以这两个方法并不是一个对象锁，`不会互斥`

### 尽量不要使用 synchronized(String a) ，因为JVM中，字符串常量池具有缓存功能

    String a = "a";
    String b = "a";
    // lock 传入 a 或者 b，都是同一把锁
    synchronized(String lock) {
    }

##  synchronized和ReentrantLock 的区别
### 两者都是可重入锁
- “可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，`如果不可锁重入的话，就会造成死锁`

### synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API
- synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们
- ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的

### ReentrantLock 比 synchronized 增加了一些高级功能
#### ReentrantLock提供了一种能够中断等待锁的线程的机制
- 通过lock.lockInterruptibly()来实现这个机制，也就是说正在等待的线程可以选择放弃等待，改为处理其他事情

#### ReentrantLock可以指定是公平锁还是非公平锁，而synchronized只能是非公平锁
- 公平锁就是先等待的线程先获得锁。ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的`ReentrantLock(boolean fair)`构造方法来制定是否是公平的

#### 可实现选择性通知（锁可以绑定多个条件--Condition）
- synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法
- Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），**线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”** ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。

###  性能已不是选择标准