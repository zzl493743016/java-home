## 面向对象和面向过程的区别
- **面向过程** ：**面向过程性能比面向对象高。** 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，**面向过程没有面向对象易维护、易复用、易扩展**
- **面向对象** ：**面向对象易维护、易复用、易扩展。** 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，**面向对象性能比面向过程低**

###  面向过程性能比面向对象高？
- 这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码
- 而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比  Java 好
- [详细参见](https://github.com/Snailclimb/JavaGuide/issues/431)

##  面向对象编程三大特性

### 封装
- 封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了

### 继承
- 继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码

#### 关于继承如下 3 点请记住：
- 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，`只是拥有`
- 子类可以拥有自己属性和方法，即子类可以对父类进行扩展
- 子类可以用自己的方式实现父类的方法

### 多态
- 所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定
- 在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）

##  Java 的值传递
- 当入参为基本数据类型时，复制值
- 当入参为引用类型时，复制指针

## JVM

### 什么是JVM
- Java 虚拟机（JVM）是运行 Java 字节码的虚拟机
- JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果

###  什么是字节码?采用字节码的好处是什么?
- 在 Java 中，JVM 可以理解的代码就叫做`字节码`（即扩展名为 `.class` 的文件），它不面向任何特定的处理器，只面向虚拟机
- Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行

### Java 程序从源代码到运行的三大步骤
![Java程序运行过程](1.基础概念.assets/12482)

### JIT
- 我们需要格外注意的是 `.class->机器码` 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的`热点代码`)，所以后面引进了 JIT 编译器，而 JIT 属于`运行时编译`
- 当 JIT 编译器完成第一次编译后，其会将字节码对应的`机器码`保存下来，下次可以`直接使用`。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言
- HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据`二八定律`，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分
- JVM 会根据代码每次被执行的情况收集信息并相应地做出一些`优化`，因此执行的次数越多，它的速度就越快

### AOT
- JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是`直接将字节码编译成机器码`，这样就`避免了 JIT 预热等各方面的开销`。JDK 支持分层编译和 AOT 协作使用
- AOT 编译器的编译质量是肯定比不上 JIT 编译器的

### JDK 和 JRE
- JDK 是 Java Development Kit，它是`功能齐全的 Java SDK`。它`拥有 JRE 所拥有的一切`，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序
- JRE 是 Java `运行时环境`。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序
> 如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet

## 构造器

### 作用是什么
- 主要作用是完成对类对象的初始化工作

### 若一个类没有声明构造方法，该程序能正确执行吗? 为什么
- 可以执行。因为一个类即使没有声明构造方法也会有`默认的不带参数`的构造方法

### 构造方法有哪些特性
- 名字与类名相同
- 没有返回值，但不能用 void 声明构造函数
- 生成类的对象时自动执行，无需调用

### 是否可被 override(重载)
- 不能被 override（重写）
- 可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况

### 在 Java 中定义一个不做事且没有参数的构造方法的作用
- Java 程序在执行子类的构造方法之前，如果没有用 `super()`来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”
- 如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 `super()`来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行
- 解决办法是在父类里加上一个不做事且没有参数的构造方法

### 在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是什么
- 帮助子类做初始化工作

## 类变量，成员变量和局部变量

### 语法形式
- **成员变量：** 属于`类`的，可以被 public，private，protect，default，static，final 等`修饰符`所修饰
- **类变量：** 成员变量的一种，必须被`static`修饰
- **局部变量：** 是在`方法`中定义的变量或是方法的参数，不能被public,private,protect,default,static 等`修饰符`所修饰，能被 `final`修饰

### 在内存中的存储方式
- **成员变量：** 堆
- **类变量：** 方法区
- **局部变量：** 栈内存

### 在内存中的生存时间
- **成员变量：** `随着实例对象的创建`而存在
- **类变量：** `随着类对象的创建`而存在
- **局部变量：** `随着方法的调用`而存在

### 赋值形式
- **成员变量：** 如果没有被赋初值:则会`自动以类型的默认值`而赋值（被final修饰的需要显示赋值）
- **类变量：** 同成员变量
- **局部变量：** `不会自动赋值`

## 静态方法和实例方法

### 区别
- **静态方法：** 可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方式，`只允许访问静态成员`
- **实例方法：** 只可以使用"对象名.方法名"的方式，`无成员访问限制`

### 在一个静态方法内调用一个非静态成员为什么是非法的
- 由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员

## 接口和抽象类

### interface（接口）
- 不能实例化
- 一个类可以实现（implements）多个接口
- 变量：定义的变量都会被隐式修饰为`public static final`
- 方法：定义的方法都会被隐式修饰为`public abstract`，可以使用`静态方法`

### abstrace（抽象类）
- 不能实例化
- 一个类只能实现（extends）一个抽象类
- 变量和方法：可以随便定义使用
- 抽象方法：不能是`private`，不能有具体实现