## 如何判断对象是否死亡
### 引用计数法
- 每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收
- 无法解决对象相互循环引用的问题（A和B两个对象相互将对方作为自己的成员变量，而成员变量的引用计数只有自身销毁的时候才能减一，这样造成即使没有外部指针访问AB，AB也不能释放）

### 可达性分析算法
![](3.对象回收.assets/12580)
- 通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的

#### GCROOT
- 虚拟机栈（栈帧中的本地变量表）中引用的对象

    public class Test {
        public static  void main(String[] args) {
            // 这里的a代表虚拟机栈（栈帧中的本地变量表）中引用的对象
        	Test a = new Test();
        	a = null;
        }
    }

- 方法区中类静态属性引用的对象

    public  class Test {
        // 这里的s代表方法区中类静态属性引用的对象
        public  static Test s;
        public static  void main(String[] args) {
        	Test a = new Test();
        	a.s = new Test();
        	a = null;
        }
    }

- 方法区中常量引用的对象

    public  class Test {
        // 这里的s代表方法区中常量引用的对象
    	public  static  final Test s = new Test();
        public static void main(String[] args) {
    	    Test a = new Test();
    	    a = null;
        }
    }

- 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象

## 对象可回收，就一定会被回收吗
- 对象的 `finalize` 方法给了对象`一次垂死挣扎的机会`，当对象不可达（可回收）时，当发生GC时，会先判断对象是否执行了 finalize 方法，如果未执行，则会先执行 finalize 方法，我们可以在此方法里将当前对象与GCRoots关联，这样执行finalize方法之后，GC会再次判断对象是否可达，如果不可达，则会被回收，如果可达，则不回收
- finalize方法`只会被执行一次`，如果第一次执行 finalize方法此对象变成了可达确实不会回收，但如果对象再次被GC，则会忽略finalize方法，对象会被回收


## 强引用，软引用，弱引用，虚引用
### 强引用(StrongReference)
- 如果一个对象具有强引用，那就类似于**必不可少的生活用品**，垃圾回收器`绝不会回收它`
- 当内存空 间不足，Java虚拟机宁愿`抛出OutOfMemoryError错误`，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题

### 软引用(SoftReference)
- 如果一个对象只具有软引用，那就类似于**可有可无的生活用品**
- 如果内存空间足够，垃圾回收器就不会回收它，如果`内存空间不足`了，就会回收这些对象的内存
- 软引用可用来实现`内存敏感的高速缓存`
> 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中

### 弱引用(WeakReference)
- 如果一个对象只具有弱引用，那就类似于**可有可无的生活用品**
- 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在`垃圾回收器线程`扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存
- 由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象
> 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中

### 虚引用（PhantomReference）
- 虚引用必须和引用队列（ReferenceQueue）联合使用
- 为一个对象设置虚 引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知
- 如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收
- 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，将这个虚引用加入引用队列，在其关联的虚引用出队前，不会彻底销毁该对象。所以可以通过检查引用队列中是否有相应的虚引用来判断对象是否已经被回收了

## 垃圾收集算法

### 标记-清除算法
#### 过程
![](3.对象回收.assets/12586)
- 首先`标记`出所有需要回收的对象
- 在标记完成后`统一回收`掉所有被标记的对象

#### 优缺点
- **缺点：** 会产生内存碎片，效率低下

### 复制算法
#### 过程
![](3.对象回收.assets/12582)
- 将可用内存按容量划分为大小相等的两块，`每次只使用其中的一块`
- 当这一块的内存用完了，就将还存活着的对象`复制`到另外一块上面， 然后再把已使用过的内存空间一次清理掉

#### 优缺点
- **优点：** 实现简单，内存效率高，不易产生碎片
- **缺点：** 可用空间被压缩到了原来的50%，存活对象增多的话，Copying 算法的效率会大大降低

### 标记-整理算法
#### 过程
![image](3.对象回收.assets/12584)
- 首先`标记`出所有需要回收的对象
- 让所有存活的对象都`向一端移动`，然后直接`清理掉端边界以外的内存`

#### 优缺点
- **优点：** 不易产生碎片
- **缺点：** 每次清理都要移动存活对象，效率低下

### 分代收集算法
一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法
- 在`新生代`中，每次收集都会有大量对象死去，所以可以选择`复制算法`，只需要付出少量对象的复制成本就可以完成每次垃圾收集
- `老年代`的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择`标记-清除`或`标记-整理`算法进行垃圾收集

## 垃圾收集器
![垃圾收集器分类](3.对象回收.assets/12588)

### Serial收集器
#### 工作原理
![](3.对象回收.assets/12590)
- Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了
- 是一个单线程收集器了。它的 **“单线程”** 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ **"Stop The World"** ），直到它收集结束
- **简单而高效（与其他收集器的单线程相比）**。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器对于运行在Client模式下的虚拟机来说是个不错的选择
- 新生代采用`复制`算法

#### 参数
- -XX:+UseSerialGC
>使用Serial + Serial Old的收集器组合进行内存回收，虚拟机运行在`Client`模式下的默认值

### ParNew收集器
#### 工作原理
![](3.对象回收.assets/12592)
- ParNew收集器其实就是Serial收集器的`多线程`版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样
- 是许多运行在`Server`模式下的虚拟机的首要选择，除了Serial收集器外，只有它能`与CMS收集器配合工作`
- 新生代采用`复制`算法

#### 参数
- -XX:+UseParNewGC
> 使用ParNew + Serial Old的收集器组合进行内存回收

### Parallel Scavenge收集器
#### 工作原理
- Parallel Scavenge收集器关注点是`吞吐量（高效率的利用CPU）`，所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值
- CMS等垃圾收集器的关注点更多的是`用户线程的停顿时间（提高用户体验）`
- 新生代采用`复制`算法

#### 参数
- -XX:+UseParallelGC
> 使用Parallel Scavenge + Serial Old的收集器组合进行内存回收，虚拟机运行在Server模式下的默认值

-XX:+UseParallelOldGC
> 使用Parallel Scavenge + Parallel Old的收集器组合进行内存回收

- -XX:MaxGCPauseMills
> 设置最大垃圾收集停顿时间

- -XX:GCTimeRatio
> 设置吞吐量大小，值是一个0到100之间的整数。假设GCTimeRatio的值为n，那么系统将花费不超过1/(1+n)的时间用于垃圾收集。默认值为99，即允许1%的GC时间

- -XX:+UseAdaptiveSizePolicy
> 打开自适应GC策略，开启这个参数后，就不需要手工指定新生代大小,Eden 与 Survivor 比例（SurvivorRatio）等细节，只需要设置好-Xmx，MaxGCPauseMills和GCTimeRatio，虚拟机就会根据当前系统运行情况收集监控信息，动态调整这些参数以尽可能地达到我们设定的最大垃圾收集时间或吞吐量大小这两个指标

### Serial Old收集器
- **Serial收集器的老年代版本**，它同样是一个单线程收集器
- 一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用
- 另一种用途是作为`CMS收集器的后备方案`
- 老年代采用`标记-整理`算法

### Parallel Old收集器
- **Parallel Scavenge收集器的老年代版本**，使用`多线程和“标记-整理”`算法
- 在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器
- 老年代采用`标记-整理`算法

### CMS收集器
#### 工作原理
![](3.对象回收.assets/12594)
- 是一种`以获取最短回收停顿时间为目标`的收集器，非常符合在`注重用户体验`的应用上使用
- 对CPU敏感（默认开启的回收线程数 (CPU个数 + 3) / 4，CPU个数越少，占用CPU资源越大）
- 产生大量内存碎片（影响大对象的存放）
- 浮动垃圾（清理过程与用核线程并行），因为并发清理的阶段，用户线程还在运行，如果CMS运行期间预留的内存不足可能会导致Concurrent Mode Failure，然后`启用Serial Old收集器`进行Full GC
- 老年代采用`标记-清除`算法

#### 工作步骤
- **初始标记：** 

    - STW
    - 标记与GC Roots关联的对象
    - 速度很快

- **并发标记：** 

    - 同时开启GC和用户线程，用一个闭包结构去记录可达对象
    - 因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性

- **重新标记：** 

    - STW
    - 为了修正并发标记期间因用户线程继续运行而导致标记产生变动的那一部分对象的标记记录
    - 这一阶段停顿时间一般比初始标记阶段稍长，但远比并发标记时间短

- **并发清除：** 

	- 开启用户线程，同时GC线程开始对为标记的区域做清扫

#### 参数
- -XX:+UseConcMarkSweepGC
> 使用ParNew + CMS的收集器组合进行内存回收

- -XX:ParallelCMSThreads
> 设定CMS的线程数量

- -XX:CMSInitiatingOccupancyFraction
> 设置CMS收集器在老年代空间被使用多少%后触发

- -XX:+UseCMSCompactAtFullCollection
> 设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理

- -XX:CMSFullGCsBeforeCompaction
> 设定进行多少次CMS垃圾回收后，进行一次内存压缩（碎片整理）

###  G1收集器
#### 工作原理
- G1 (Garbage-First)是一款面向服务器的垃圾收集器，主要针对配备`多颗处理器`及`大容量内存`的机器
- 以极高概率满足`GC停顿时间`要求的同时，还具备`高吞吐量性能`特征
- **并行与并发**：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行
- **分代收集**：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念
- **空间整合**：G1从整体来看是基于`标记-整理`算法实现的收集器；从局部上来看是基于`复制`算法实现的
- **可预测的停顿**：G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。

#### 工作步骤
- **初始标记**
- **并发标记**
- **最终标记**
- **筛选回收**
- G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)
- 这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）

#### 参数
- -XX:+UseG1GC
> 使用G1垃圾回收器

- -XX:MaxGCPauseMillis=200
> 设置GC暂停时间目标值,缺省200毫秒，这不是硬指标,JVM会尽力满足

- -XX:InitiatingHeapOccupancyPercent=45
> 整个堆被占用多少%之后开始进行GC，缺省为45%，0表示持续不停进行GC

- -XX:G1ReservePercent=n
> 保留的堆大小,减少晋升过程中出错的可能性,也就是增加可用的to-space内存,缺省是10

- -XX:G1HeapRegionSize=n
> 设置区域的大小,缺省值取决于堆的总大小,有效取值是1M-32M。

- -XX:ConcGCThreads=n
> 增加标记线程数目

#### G1最佳实践

- 不要设置年轻代的大小(-Xmn)，否则会扰乱G1的缺省行为，JVM也不会满足用户指定的暂停时间，而且设置了固定值的话，G1将无法随需扩展年轻代的大小
- GC暂停时间不是100%能保证的
- 如果GC的晋升过程中遇到堆区域溢出(使用-XX:+PrintGCDetails看到to-space overflow),可以通过下面几种方式避免:

    - 增加-XX:G1ReservePercent=n,缺省值是10。这可以增加可用的to-space内存
    - 使用-XX:ConcGCThreads=n增加标记线程数目

